{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://dead-code-finder/./src/views/deadCodeView.ts","webpack://dead-code-finder/./src/commands/navigation.ts","webpack://dead-code-finder/./src/commands/whitelist.ts","webpack://dead-code-finder/./src/extension.ts","webpack://dead-code-finder/./src/analyzers/python/vulture.ts","webpack://dead-code-finder/external node-commonjs \"child_process\"","webpack://dead-code-finder/external commonjs \"vscode\"","webpack://dead-code-finder/./src/analyzers/python/whitelist.ts","webpack://dead-code-finder/./src/utils/logging.ts","webpack://dead-code-finder/./src/utils/process.ts","webpack://dead-code-finder/./src/commands/analyze.ts","webpack://dead-code-finder/./src/analyzers/python/pythonAnalyzer.ts","webpack://dead-code-finder/external node-commonjs \"fs\"","webpack://dead-code-finder/external node-commonjs \"path\"","webpack://dead-code-finder/./src/providers/diagnostics.ts","webpack://dead-code-finder/webpack/bootstrap","webpack://dead-code-finder/webpack/startup"],"sourcesContent":["import * as vscode from \"vscode\";\nimport * as path from \"path\";\nimport { DeadCodeItem } from \"../analyzers/analyzer\";\nimport { Logger } from \"../utils/logging\";\n\n/**\n * Tree item types for the dead code tree view\n */\nexport enum DeadCodeTreeItemType {\n  FILE,\n  DEAD_CODE_ITEM,\n}\n\n/**\n * Tree item representing a file or dead code item in the tree view\n */\nexport class DeadCodeTreeItem extends vscode.TreeItem {\n  constructor(\n    public readonly label: string,\n    public readonly type: DeadCodeTreeItemType,\n    public readonly deadCodeItem?: DeadCodeItem,\n    public readonly children: DeadCodeTreeItem[] = []\n  ) {\n    super(\n      label,\n      type === DeadCodeTreeItemType.FILE\n        ? vscode.TreeItemCollapsibleState.Expanded\n        : vscode.TreeItemCollapsibleState.None\n    );\n\n    // Set properties based on type\n    if (type === DeadCodeTreeItemType.FILE) {\n      this.iconPath = {\n        light: path.join(\n          __filename,\n          \"..\",\n          \"..\",\n          \"..\",\n          \"resources\",\n          \"light\",\n          \"file.svg\"\n        ),\n        dark: path.join(\n          __filename,\n          \"..\",\n          \"..\",\n          \"..\",\n          \"resources\",\n          \"dark\",\n          \"file.svg\"\n        ),\n      };\n      this.description = \"\";\n    } else if (deadCodeItem) {\n      this.iconPath = {\n        light: path.join(\n          __filename,\n          \"..\",\n          \"..\",\n          \"..\",\n          \"resources\",\n          \"light\",\n          \"method.svg\"\n        ),\n        dark: path.join(\n          __filename,\n          \"..\",\n          \"..\",\n          \"..\",\n          \"resources\",\n          \"dark\",\n          \"method.svg\"\n        ),\n      };\n      this.description = `${deadCodeItem.type} (${deadCodeItem.confidence}% confidence)`;\n      this.tooltip =\n        deadCodeItem.details ||\n        `${deadCodeItem.type} '${deadCodeItem.name}' at line ${deadCodeItem.lineNumber}`;\n      this.command = {\n        title: \"Open Dead Code\",\n        command: \"deadCodeFinder.openDeadCode\",\n        arguments: [deadCodeItem],\n      };\n    }\n\n    this.contextValue =\n      type === DeadCodeTreeItemType.DEAD_CODE_ITEM ? \"deadCodeItem\" : \"file\";\n  }\n}\n\n/**\n * Tree data provider for the dead code tree view\n */\nexport class DeadCodeTreeProvider\n  implements vscode.TreeDataProvider<DeadCodeTreeItem>\n{\n  private _onDidChangeTreeData: vscode.EventEmitter<\n    DeadCodeTreeItem | undefined\n  > = new vscode.EventEmitter<DeadCodeTreeItem | undefined>();\n  readonly onDidChangeTreeData: vscode.Event<DeadCodeTreeItem | undefined> =\n    this._onDidChangeTreeData.event;\n\n  private _items: DeadCodeItem[] = [];\n  private _treeItems: DeadCodeTreeItem[] = [];\n\n  /**\n   * Refresh the tree view\n   */\n  public refresh(items: DeadCodeItem[] = []): void {\n    Logger.debug(`Refreshing DeadCodeTreeProvider with ${items.length} items`);\n    this._items = items;\n    this._treeItems = this.buildTreeItems(items);\n    this._onDidChangeTreeData.fire(undefined);\n  }\n\n  /**\n   * Get the tree item for a given element\n   */\n  public getTreeItem(element: DeadCodeTreeItem): vscode.TreeItem {\n    return element;\n  }\n\n  /**\n   * Get the children of a given element\n   */\n  public getChildren(element?: DeadCodeTreeItem): Thenable<DeadCodeTreeItem[]> {\n    if (!element) {\n      return Promise.resolve(this._treeItems);\n    }\n    return Promise.resolve(element.children);\n  }\n\n  /**\n   * Get all dead code items\n   */\n  public getItems(): DeadCodeItem[] {\n    return this._items;\n  }\n\n  /**\n   * Build tree items from dead code items\n   */\n  private buildTreeItems(items: DeadCodeItem[]): DeadCodeTreeItem[] {\n    // Group items by file\n    const fileMap = new Map<string, DeadCodeItem[]>();\n\n    for (const item of items) {\n      const filePath = item.filePath;\n      if (!fileMap.has(filePath)) {\n        fileMap.set(filePath, []);\n      }\n      fileMap.get(filePath)!.push(item);\n    }\n\n    // Create tree items\n    const result: DeadCodeTreeItem[] = [];\n\n    fileMap.forEach((fileItems, filePath) => {\n      // Create child items\n      const children: DeadCodeTreeItem[] = [];\n\n      // Sort items by line number\n      fileItems.sort((a, b) => a.lineNumber - b.lineNumber);\n\n      for (const item of fileItems) {\n        children.push(\n          new DeadCodeTreeItem(\n            item.name,\n            DeadCodeTreeItemType.DEAD_CODE_ITEM,\n            item\n          )\n        );\n      }\n\n      // Create parent file item\n      const fileItem = new DeadCodeTreeItem(\n        path.basename(filePath),\n        DeadCodeTreeItemType.FILE,\n        undefined,\n        children\n      );\n\n      fileItem.description = path.dirname(filePath);\n      result.push(fileItem);\n    });\n\n    // Sort files alphabetically\n    result.sort((a, b) => a.label.localeCompare(b.label));\n\n    return result;\n  }\n}\n\n/**\n * Register the dead code tree view\n */\nexport function registerDeadCodeTreeView(context: vscode.ExtensionContext): {\n  treeDataProvider: DeadCodeTreeProvider;\n  treeView: vscode.TreeView<DeadCodeTreeItem>;\n} {\n  const treeDataProvider = new DeadCodeTreeProvider();\n  const treeView = vscode.window.createTreeView(\"deadCodeExplorer\", {\n    treeDataProvider,\n    showCollapseAll: true,\n  });\n\n  context.subscriptions.push(treeView);\n\n  return { treeDataProvider, treeView };\n}\n","import * as vscode from \"vscode\";\nimport { DeadCodeItem } from \"../analyzers/analyzer\";\nimport { Logger } from \"../utils/logging\";\n\n/**\n * Register commands for navigating to dead code\n */\nexport function registerNavigationCommands(\n  context: vscode.ExtensionContext\n): void {\n  // Register command to open a dead code item\n  const openDeadCodeCommand = vscode.commands.registerCommand(\n    \"deadCodeFinder.openDeadCode\",\n    async (item: DeadCodeItem) => {\n      await openDeadCode(item);\n    }\n  );\n  context.subscriptions.push(openDeadCodeCommand);\n\n  // Register command to open settings\n  const openSettingsCommand = vscode.commands.registerCommand(\n    \"deadCodeFinder.openSettings\",\n    async () => {\n      await openSettings();\n    }\n  );\n  context.subscriptions.push(openSettingsCommand);\n}\n\n/**\n * Open a document at the line containing dead code\n */\nasync function openDeadCode(item: DeadCodeItem): Promise<void> {\n  try {\n    Logger.info(`Opening file at line ${item.lineNumber}: ${item.filePath}`);\n\n    // Create a URI for the file\n    const uri = vscode.Uri.file(item.filePath);\n\n    // Open the document\n    const document = await vscode.workspace.openTextDocument(uri);\n    const editor = await vscode.window.showTextDocument(document);\n\n    // Get zero-based line number\n    const lineNumber = Math.max(0, item.lineNumber - 1);\n\n    // Create a range for the line\n    const range = document.lineAt(lineNumber).range;\n\n    // Reveal the line in the editor\n    editor.revealRange(range, vscode.TextEditorRevealType.InCenter);\n\n    // Select the line\n    editor.selection = new vscode.Selection(range.start, range.end);\n  } catch (error) {\n    Logger.error(`Error opening dead code location`, error as Error);\n    vscode.window.showErrorMessage(\n      `Error opening file: ${(error as Error).message}`\n    );\n  }\n}\n\n/**\n * Open extension settings\n */\nasync function openSettings(): Promise<void> {\n  Logger.info(\"Opening Dead Code Finder settings\");\n  await vscode.commands.executeCommand(\n    \"workbench.action.openSettings\",\n    \"deadCodeFinder\"\n  );\n}\n","import * as vscode from \"vscode\";\nimport { DeadCodeItem } from \"../analyzers/analyzer\";\nimport { generateWhitelist } from \"../analyzers/python/whitelist\";\nimport { Logger } from \"../utils/logging\";\n\n/**\n * Register whitelist commands\n */\nexport function registerWhitelistCommands(\n  context: vscode.ExtensionContext,\n  getDeadCodeItems: () => DeadCodeItem[]\n): void {\n  // Command to generate a whitelist from current results\n  const generateWhitelistCommand = vscode.commands.registerCommand(\n    \"deadCodeFinder.generateWhitelist\",\n    async () => {\n      await generateWhitelistFromResults(getDeadCodeItems);\n    }\n  );\n  context.subscriptions.push(generateWhitelistCommand);\n\n  // Command to whitelist a specific item\n  const whitelistItemCommand = vscode.commands.registerCommand(\n    \"deadCodeFinder.whitelistItem\",\n    async (item: DeadCodeItem) => {\n      await whitelistSingleItem(item);\n    }\n  );\n  context.subscriptions.push(whitelistItemCommand);\n}\n\n/**\n * Generate a whitelist file from current dead code results\n */\nasync function generateWhitelistFromResults(\n  getDeadCodeItems: () => DeadCodeItem[]\n): Promise<void> {\n  try {\n    const items = getDeadCodeItems();\n\n    if (items.length === 0) {\n      vscode.window.showInformationMessage(\n        \"No dead code items to whitelist. Run an analysis first.\"\n      );\n      return;\n    }\n\n    Logger.info(`Generating whitelist for ${items.length} items`);\n    await generateWhitelist(items);\n  } catch (error) {\n    Logger.error(\"Error generating whitelist\", error as Error);\n    vscode.window.showErrorMessage(\n      `Error generating whitelist: ${(error as Error).message}`\n    );\n  }\n}\n\n/**\n * Add a single item to the whitelist\n */\nasync function whitelistSingleItem(item: DeadCodeItem): Promise<void> {\n  try {\n    Logger.info(`Whitelisting item: ${item.name}`);\n    await generateWhitelist([item]);\n  } catch (error) {\n    Logger.error(`Error whitelisting item: ${item.name}`, error as Error);\n    vscode.window.showErrorMessage(\n      `Error whitelisting item: ${(error as Error).message}`\n    );\n  }\n}\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from \"vscode\";\nimport { Logger } from \"./utils/logging\";\nimport { registerDeadCodeTreeView } from \"./views/deadCodeView\";\nimport { registerAnalyzeCommand } from \"./commands/analyze\";\nimport { registerNavigationCommands } from \"./commands/navigation\";\nimport { registerWhitelistCommands } from \"./commands/whitelist\";\nimport {\n  initDiagnosticsProvider,\n  updateDiagnostics,\n  clearDiagnostics,\n} from \"./providers/diagnostics\";\nimport { DeadCodeItem } from \"./analyzers/analyzer\";\n\n// This method is called when your extension is activated\n// Your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n  // Initialize logger\n  Logger.initialize(context);\n  Logger.info(\"Activating Dead Code Finder extension\");\n\n  // Initialize diagnostics provider\n  initDiagnosticsProvider(context);\n\n  // Store dead code items for access across commands\n  let deadCodeItems: DeadCodeItem[] = [];\n\n  // Register the tree view for displaying dead code results\n  const { treeDataProvider } = registerDeadCodeTreeView(context);\n\n  // Register commands for analyzing code\n  registerAnalyzeCommand(context, (items: DeadCodeItem[]) => {\n    // Store items for other commands\n    deadCodeItems = items;\n\n    // Update tree view with results\n    treeDataProvider.refresh(items);\n\n    // Update diagnostics\n    const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n    if (config.get<boolean>(\"showDiagnostics\", true)) {\n      updateDiagnostics(items);\n    } else {\n      clearDiagnostics();\n    }\n  });\n\n  // Register navigation commands\n  registerNavigationCommands(context);\n\n  // Register whitelist commands\n  registerWhitelistCommands(context, () => deadCodeItems);\n\n  // Set up configuration change listener\n  const configWatcher = vscode.workspace.onDidChangeConfiguration((e) => {\n    if (e.affectsConfiguration(\"deadCodeFinder\")) {\n      // Update logger level based on configuration\n      const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n      const logLevel = config.get<string>(\"logLevel\", \"info\");\n      Logger.info(`Configuration changed, updating log level to ${logLevel}`);\n\n      // Handle diagnostics visibility change\n      if (e.affectsConfiguration(\"deadCodeFinder.showDiagnostics\")) {\n        if (config.get<boolean>(\"showDiagnostics\", true)) {\n          updateDiagnostics(deadCodeItems);\n        } else {\n          clearDiagnostics();\n        }\n      }\n    }\n  });\n  context.subscriptions.push(configWatcher);\n\n  // Setup auto-analysis on file save if enabled\n  const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n  if (config.get<boolean>(\"enableAutoAnalysis\", false)) {\n    setupAutoAnalysis(context, treeDataProvider);\n  }\n\n  Logger.info(\"Dead Code Finder extension activated\");\n}\n\n/**\n * Set up auto-analysis on file save\n */\nfunction setupAutoAnalysis(\n  context: vscode.ExtensionContext,\n  treeDataProvider: any\n) {\n  const fileWatcher = vscode.workspace.onDidSaveTextDocument((document) => {\n    // Only analyze Python files for now\n    if (document.languageId === \"python\") {\n      const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n      if (config.get<boolean>(\"enableAutoAnalysis\", false)) {\n        Logger.debug(`Auto-analyzing file: ${document.fileName}`);\n        vscode.commands.executeCommand(\"deadCodeFinder.analyzeFile\");\n      }\n    }\n  });\n  context.subscriptions.push(fileWatcher);\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {\n  // Clear diagnostics on deactivation\n  clearDiagnostics();\n  Logger.info(\"Deactivating Dead Code Finder extension\");\n}\n","import * as vscode from \"vscode\";\nimport * as path from \"path\";\nimport * as fs from \"fs\";\nimport { DeadCodeItem, AnalysisResult } from \"../analyzer\";\nimport {\n  executeCommand,\n  executePythonCommand,\n  ProcessResult,\n} from \"../../utils/process\";\nimport { Logger } from \"../../utils/logging\";\n\n/**\n * Pattern to match Vulture output lines\n * Example: path/to/file.py:42: unused function 'my_function' (60% confidence)\n */\nconst VULTURE_OUTPUT_PATTERN =\n  /^(.+):(\\d+): unused (.+) '(.+)' \\((\\d+)% confidence\\)$/;\n\n/**\n * Check if Vulture is installed\n */\nexport async function isVultureInstalled(): Promise<boolean> {\n  try {\n    const result = await executePythonCommand([\"-m\", \"pip\", \"show\", \"vulture\"]);\n    return result.code === 0;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Install Vulture via pip\n */\nexport async function installVulture(): Promise<boolean> {\n  try {\n    Logger.info(\"Installing Vulture...\");\n\n    // Show progress notification to the user\n    return await vscode.window.withProgress(\n      {\n        location: vscode.ProgressLocation.Notification,\n        title: \"Installing Vulture...\",\n        cancellable: false,\n      },\n      async (progress) => {\n        progress.report({ increment: 0, message: \"Starting installation...\" });\n\n        // Try with pip first\n        let result = await executePythonCommand([\n          \"-m\",\n          \"pip\",\n          \"install\",\n          \"vulture\",\n          \"--user\", // Add --user flag to avoid permission issues\n        ]);\n\n        // If pip fails, try with pip3\n        if (result.code !== 0) {\n          progress.report({\n            increment: 30,\n            message: \"Trying alternate installation method...\",\n          });\n\n          // Try with pip3 if pip fails\n          result = await executePythonCommand([\n            \"-m\",\n            \"pip3\",\n            \"install\",\n            \"vulture\",\n            \"--user\",\n          ]);\n        }\n\n        progress.report({\n          increment: 70,\n          message: \"Verifying installation...\",\n        });\n\n        // Verify installation was successful\n        const verifyResult = await isVultureInstalled();\n\n        if (result.code === 0 && verifyResult) {\n          progress.report({ increment: 100, message: \"Installation complete\" });\n          Logger.info(\"Vulture installed successfully\");\n          vscode.window.showInformationMessage(\n            \"Vulture installed successfully\"\n          );\n          return true;\n        } else {\n          Logger.error(`Failed to install Vulture: ${result.stderr}`);\n          // Show detailed error message with installation instructions\n          vscode.window\n            .showErrorMessage(\n              \"Failed to install Vulture automatically. Please try installing manually with 'pip install vulture' in your terminal.\",\n              \"Open Terminal\"\n            )\n            .then((selection) => {\n              if (selection === \"Open Terminal\") {\n                const terminal = vscode.window.createTerminal(\n                  \"Vulture Installation\"\n                );\n                terminal.show();\n                terminal.sendText(\"pip install vulture --user\");\n              }\n            });\n          return false;\n        }\n      }\n    );\n  } catch (error) {\n    Logger.error(\"Error installing Vulture\", error as Error);\n    vscode.window.showErrorMessage(\n      `Error installing Vulture: ${\n        (error as Error).message\n      }. Please try installing manually with 'pip install vulture'.`\n    );\n    return false;\n  }\n}\n\n/**\n * Run Vulture analysis on the given paths\n */\nexport async function runVultureAnalysis(\n  paths: string[],\n  minConfidence: number = 60\n): Promise<AnalysisResult> {\n  const result: AnalysisResult = {\n    deadCodeItems: [],\n    errors: [],\n    warnings: [],\n    success: false,\n  };\n\n  try {\n    // Prepare vulture command\n    const args = [\n      \"-m\",\n      \"vulture\",\n      \"--min-confidence\",\n      minConfidence.toString(),\n      ...paths,\n    ];\n\n    // Get whitelist file if specified\n    const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n    const whitelistFile = config.get<string>(\"whitelistFile\");\n    if (whitelistFile && fs.existsSync(whitelistFile)) {\n      args.push(whitelistFile);\n    }\n\n    // Run vulture\n    Logger.debug(`Running Vulture with args: ${args.join(\" \")}`);\n    const processResult = await executePythonCommand(args);\n\n    // Check for errors\n    if (processResult.code !== 0 && processResult.code !== 3) {\n      // Code 3 means dead code was found, which is what we want\n      result.errors.push(`Vulture exited with code ${processResult.code}`);\n      if (processResult.stderr) {\n        result.errors.push(processResult.stderr);\n      }\n      return result;\n    }\n\n    // Parse output\n    result.deadCodeItems = parseVultureOutput(processResult);\n    result.success = true;\n\n    Logger.info(`Vulture found ${result.deadCodeItems.length} dead code items`);\n    return result;\n  } catch (error) {\n    const err = error as Error;\n    result.errors.push(err.message);\n    Logger.error(\"Error running Vulture analysis\", err);\n    return result;\n  }\n}\n\n/**\n * Parse the output from Vulture into DeadCodeItem objects\n */\nexport function parseVultureOutput(\n  processResult: ProcessResult\n): DeadCodeItem[] {\n  const items: DeadCodeItem[] = [];\n\n  if (!processResult.stdout) {\n    return items;\n  }\n\n  const lines = processResult.stdout.split(\"\\n\");\n\n  for (const line of lines) {\n    if (!line.trim()) {\n      continue;\n    }\n\n    const match = line.match(VULTURE_OUTPUT_PATTERN);\n    if (match) {\n      const [_, filePath, lineNumber, type, name, confidence] = match;\n\n      items.push({\n        filePath: filePath,\n        lineNumber: parseInt(lineNumber, 10),\n        name: name,\n        type: type,\n        confidence: parseInt(confidence, 10),\n        details: line,\n      });\n    } else {\n      Logger.debug(`Could not parse Vulture output line: ${line}`);\n    }\n  }\n\n  return items;\n}\n","module.exports = require(\"child_process\");","module.exports = require(\"vscode\");","import * as vscode from \"vscode\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { DeadCodeItem } from \"../analyzer\";\nimport { Logger } from \"../../utils/logging\";\n\n/**\n * Default whitelist file name\n */\nexport const DEFAULT_WHITELIST_FILENAME = \"whitelist.py\";\n\n/**\n * Generate a whitelist entry for a dead code item\n */\nexport function generateWhitelistEntry(item: DeadCodeItem): string {\n  // Extract module path from file path\n  const filePath = item.filePath;\n  const fileExt = path.extname(filePath);\n  const modulePath = filePath\n    .substring(0, filePath.length - fileExt.length)\n    .replace(/[\\/\\\\]/g, \".\");\n\n  // Generate import statement and whitelist line\n  return `from ${modulePath} import ${item.name}\\n${item.name}\\n`;\n}\n\n/**\n * Generate a whitelist file for a list of dead code items\n */\nexport async function generateWhitelist(\n  items: DeadCodeItem[],\n  targetPath?: string\n): Promise<string | undefined> {\n  try {\n    // Determine whitelist file path\n    const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n    const whitelistPath = targetPath || config.get<string>(\"whitelistFile\");\n\n    if (!whitelistPath) {\n      // If no path specified, ask the user for a location\n      const workspaceFolders = vscode.workspace.workspaceFolders;\n      if (!workspaceFolders) {\n        vscode.window.showErrorMessage(\"No workspace folder open\");\n        return undefined;\n      }\n\n      const defaultUri = vscode.Uri.file(\n        path.join(workspaceFolders[0].uri.fsPath, DEFAULT_WHITELIST_FILENAME)\n      );\n      const uri = await vscode.window.showSaveDialog({\n        defaultUri,\n        filters: {\n          \"Python Files\": [\"py\"],\n        },\n        title: \"Save Whitelist File\",\n      });\n\n      if (!uri) {\n        return undefined;\n      }\n\n      return generateWhitelistFile(items, uri.fsPath);\n    }\n\n    return generateWhitelistFile(items, whitelistPath);\n  } catch (error) {\n    Logger.error(\"Error generating whitelist\", error as Error);\n    vscode.window.showErrorMessage(\n      `Error generating whitelist: ${(error as Error).message}`\n    );\n    return undefined;\n  }\n}\n\n/**\n * Generate the actual whitelist file content and write to disk\n */\nasync function generateWhitelistFile(\n  items: DeadCodeItem[],\n  filePath: string\n): Promise<string> {\n  try {\n    // Generate whitelist content\n    let content = \"# Whitelist for Vulture\\n\";\n    content += \"# Generated by Dead Code Finder VSCode extension\\n\\n\";\n\n    // Add each item to the whitelist\n    const uniqueItems = new Map<string, DeadCodeItem>();\n    for (const item of items) {\n      uniqueItems.set(item.name, item);\n    }\n\n    for (const item of uniqueItems.values()) {\n      content += generateWhitelistEntry(item);\n    }\n\n    // Write to file\n    fs.writeFileSync(filePath, content, \"utf8\");\n\n    Logger.info(`Generated whitelist at ${filePath}`);\n    vscode.window.showInformationMessage(`Whitelist generated at ${filePath}`);\n\n    return filePath;\n  } catch (error) {\n    Logger.error(`Error writing whitelist to ${filePath}`, error as Error);\n    throw error;\n  }\n}\n","import * as vscode from \"vscode\";\n\n/**\n * Logging levels for the extension\n */\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\n/**\n * Logger class for the extension\n */\nexport class Logger {\n  private static _outputChannel: vscode.OutputChannel;\n  private static _logLevel: LogLevel = LogLevel.INFO;\n\n  /**\n   * Initialize the logger\n   */\n  public static initialize(context: vscode.ExtensionContext) {\n    this._outputChannel = vscode.window.createOutputChannel(\"Dead Code Finder\");\n    context.subscriptions.push(this._outputChannel);\n\n    // Get the log level from configuration\n    const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n    const configLevel = config.get<string>(\"logLevel\", \"info\");\n    this._logLevel = this.getLogLevelFromString(configLevel);\n  }\n\n  /**\n   * Set the logging level\n   */\n  public static setLogLevel(level: LogLevel) {\n    this._logLevel = level;\n  }\n\n  /**\n   * Log a debug message\n   */\n  public static debug(message: string) {\n    this.log(LogLevel.DEBUG, message);\n  }\n\n  /**\n   * Log an info message\n   */\n  public static info(message: string) {\n    this.log(LogLevel.INFO, message);\n  }\n\n  /**\n   * Log a warning message\n   */\n  public static warn(message: string) {\n    this.log(LogLevel.WARN, message);\n  }\n\n  /**\n   * Log an error message\n   */\n  public static error(message: string, error?: Error) {\n    let fullMessage = message;\n    if (error) {\n      fullMessage += `\\n${error.message}`;\n      if (error.stack) {\n        fullMessage += `\\n${error.stack}`;\n      }\n    }\n    this.log(LogLevel.ERROR, fullMessage);\n  }\n\n  /**\n   * Log a message at the specified level\n   */\n  private static log(level: LogLevel, message: string) {\n    if (level < this._logLevel) {\n      return;\n    }\n\n    if (!this._outputChannel) {\n      // Create output channel if not initialized\n      this._outputChannel =\n        vscode.window.createOutputChannel(\"Dead Code Finder\");\n    }\n\n    const timestamp = new Date().toISOString();\n    const levelStr = LogLevel[level];\n    const formattedMessage = `[${timestamp}] [${levelStr}] ${message}`;\n\n    this._outputChannel.appendLine(formattedMessage);\n  }\n\n  /**\n   * Convert a string log level to the enum value\n   */\n  private static getLogLevelFromString(level: string): LogLevel {\n    switch (level.toLowerCase()) {\n      case \"debug\":\n        return LogLevel.DEBUG;\n      case \"info\":\n        return LogLevel.INFO;\n      case \"warn\":\n      case \"warning\":\n        return LogLevel.WARN;\n      case \"error\":\n        return LogLevel.ERROR;\n      default:\n        return LogLevel.INFO;\n    }\n  }\n\n  /**\n   * Show the output channel\n   */\n  public static show() {\n    this._outputChannel.show();\n  }\n}\n","import * as cp from \"child_process\";\nimport * as vscode from \"vscode\";\n\n/**\n * Result of a process execution\n */\nexport interface ProcessResult {\n  /** Standard output from the process */\n  stdout: string;\n  /** Standard error from the process */\n  stderr: string;\n  /** Exit code of the process */\n  code: number | null;\n}\n\n/**\n * Execute a command as a child process\n * @param command The command to execute\n * @param args Arguments to pass to the command\n * @param options Options for executing the command\n * @returns Promise with the process result\n */\nexport async function executeCommand(\n  command: string,\n  args: string[],\n  options: cp.ExecOptions = {}\n): Promise<ProcessResult> {\n  return new Promise<ProcessResult>((resolve) => {\n    const process = cp.spawn(command, args, options);\n    let stdout = \"\";\n    let stderr = \"\";\n\n    process.stdout?.on(\"data\", (data) => {\n      stdout += data.toString();\n    });\n\n    process.stderr?.on(\"data\", (data) => {\n      stderr += data.toString();\n    });\n\n    process.on(\"close\", (code) => {\n      resolve({ stdout, stderr, code });\n    });\n\n    process.on(\"error\", (err) => {\n      stderr += err.message;\n      resolve({ stdout, stderr, code: null });\n    });\n  });\n}\n\n/**\n * Check if a command is available in the system\n * @param command The command to check\n * @returns Promise resolving to true if the command is available\n */\nexport async function isCommandAvailable(command: string): Promise<boolean> {\n  try {\n    const isWindows = process.platform === \"win32\";\n    const testCommand = isWindows ? \"where\" : \"which\";\n    const testArgs = isWindows ? [command] : [command];\n\n    const result = await executeCommand(testCommand, testArgs);\n    return result.code === 0;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Execute a Python command (handling Python executable selection)\n * @param args Arguments to pass to the Python interpreter\n * @param options Options for executing the command\n * @returns Promise with the process result\n */\nexport async function executePythonCommand(\n  args: string[],\n  options: cp.ExecOptions = {}\n): Promise<ProcessResult> {\n  // Try to get python path from VS Code Python extension\n  const pythonConfig = vscode.workspace.getConfiguration(\"python\");\n  let pythonPath =\n    pythonConfig.get<string>(\"defaultInterpreterPath\") || \"python\";\n\n  // Try multiple Python paths in sequence if the first one fails\n  // Start with most common paths that should work for most users\n  const pythonPaths = [\n    // VS Code configured Python (most reliable if set)\n    pythonPath,\n    // Standard system commands (should work for most users)\n    \"python\",\n    \"python3\",\n    // Common system paths\n    \"/usr/bin/python3\",\n    \"/usr/bin/python\",\n    \"/usr/local/bin/python3\",\n    \"/usr/local/bin/python\",\n  ];\n\n  // Add platform-specific paths\n  if (process.platform === \"win32\") {\n    // Windows Python installations\n    pythonPaths.push(\n      \"C:\\\\Python39\\\\python.exe\",\n      \"C:\\\\Python310\\\\python.exe\",\n      \"C:\\\\Python311\\\\python.exe\"\n    );\n  } else if (process.platform === \"darwin\") {\n    // macOS homebrew and other common paths\n    pythonPaths.push(\"/opt/homebrew/bin/python3\", \"/opt/local/bin/python3\");\n  }\n\n  // Add virtual env paths - used by all Python version managers\n  if (process.env.VIRTUAL_ENV) {\n    // If a virtual environment is active, prioritize its Python\n    pythonPaths.unshift(\n      `${process.env.VIRTUAL_ENV}/bin/python`,\n      `${process.env.VIRTUAL_ENV}/Scripts/python.exe` // For Windows\n    );\n  }\n\n  // Try each Python executable in sequence\n  for (const path of pythonPaths) {\n    try {\n      const result = await executeCommand(path, args, options);\n      // If successful or has any output (even with errors), return the result\n      if (result.code === 0 || result.code === 3 || result.stdout.length > 0) {\n        // Remember this path for future calls if it's valid\n        if (\n          path.startsWith(\"/\") ||\n          path.startsWith(\"C:\\\\\") ||\n          !path.includes(\"/\")\n        ) {\n          try {\n            pythonConfig.update(\n              \"defaultInterpreterPath\",\n              path,\n              vscode.ConfigurationTarget.Global\n            );\n          } catch (error) {\n            // Ignore errors updating config\n          }\n        }\n        return result;\n      }\n    } catch (error) {\n      // Continue to the next path\n    }\n  }\n\n  // Add version managers only as a last resort\n  if (process.env.HOME) {\n    // Common version manager paths\n    const versionManagerPaths = [];\n\n    // pyenv\n    if (process.platform !== \"win32\") {\n      versionManagerPaths.push(\n        `${process.env.HOME}/.pyenv/shims/python`,\n        `${process.env.HOME}/.pyenv/shims/python3`\n      );\n    }\n\n    // Try version manager paths\n    for (const path of versionManagerPaths) {\n      try {\n        const result = await executeCommand(path, args, options);\n        if (\n          result.code === 0 ||\n          result.code === 3 ||\n          result.stdout.length > 0\n        ) {\n          try {\n            pythonConfig.update(\n              \"defaultInterpreterPath\",\n              path,\n              vscode.ConfigurationTarget.Global\n            );\n          } catch (error) {\n            // Ignore errors updating config\n          }\n          return result;\n        }\n      } catch (error) {\n        // Continue to the next path\n      }\n    }\n  }\n\n  // If all paths failed, return a more descriptive error\n  return {\n    stdout: \"\",\n    stderr: `Failed to execute Python command. Could not find a working Python interpreter with required packages.`,\n    code: null,\n  };\n}\n","import * as vscode from \"vscode\";\nimport { PythonAnalyzer } from \"../analyzers/python/pythonAnalyzer\";\nimport { DeadCodeItem } from \"../analyzers/analyzer\";\nimport { Logger } from \"../utils/logging\";\n\n/**\n * Status bar item for showing analysis status\n */\nlet statusBarItem: vscode.StatusBarItem;\n\n/**\n * Register the analyze command and status bar item\n */\nexport function registerAnalyzeCommand(\n  context: vscode.ExtensionContext,\n  onAnalysisComplete: (items: DeadCodeItem[]) => void\n): void {\n  // Create status bar item\n  statusBarItem = vscode.window.createStatusBarItem(\n    vscode.StatusBarAlignment.Left,\n    100\n  );\n  statusBarItem.text = \"$(search) Find Dead Code\";\n  statusBarItem.command = \"deadCodeFinder.analyze\";\n  statusBarItem.tooltip = \"Find unused methods and functions in your code\";\n  context.subscriptions.push(statusBarItem);\n  statusBarItem.show();\n\n  // Register command for analyzing the workspace\n  const analyzeCommand = vscode.commands.registerCommand(\n    \"deadCodeFinder.analyze\",\n    async () => {\n      await analyzeWorkspace(onAnalysisComplete);\n    }\n  );\n  context.subscriptions.push(analyzeCommand);\n\n  // Register command for analyzing the current file\n  const analyzeFileCommand = vscode.commands.registerCommand(\n    \"deadCodeFinder.analyzeFile\",\n    async () => {\n      const editor = vscode.window.activeTextEditor;\n      if (!editor) {\n        vscode.window.showWarningMessage(\"No active file to analyze\");\n        return;\n      }\n\n      await analyzeFile(editor.document.uri.fsPath, onAnalysisComplete);\n    }\n  );\n  context.subscriptions.push(analyzeFileCommand);\n}\n\n/**\n * Analyze Python files in the workspace\n */\nexport async function analyzeWorkspace(\n  onAnalysisComplete: (items: DeadCodeItem[]) => void\n): Promise<void> {\n  try {\n    Logger.info(\"Starting workspace analysis\");\n    updateStatus(\"$(sync~spin) Analyzing workspace...\");\n\n    // Get Python files in workspace\n    const pythonFiles = await PythonAnalyzer.getWorkspacePythonFiles();\n    if (pythonFiles.length === 0) {\n      vscode.window.showInformationMessage(\n        \"No Python files found in workspace\"\n      );\n      updateStatus(\"$(search) Find Dead Code\");\n      return;\n    }\n\n    Logger.debug(`Found ${pythonFiles.length} Python files to analyze`);\n    await analyzePaths(pythonFiles, onAnalysisComplete);\n  } catch (error) {\n    Logger.error(\"Error analyzing workspace\", error as Error);\n    vscode.window.showErrorMessage(\n      `Error analyzing workspace: ${(error as Error).message}`\n    );\n    updateStatus(\"$(search) Find Dead Code\");\n  }\n}\n\n/**\n * Analyze a specific Python file\n */\nexport async function analyzeFile(\n  filePath: string,\n  onAnalysisComplete: (items: DeadCodeItem[]) => void\n): Promise<void> {\n  try {\n    Logger.info(`Starting analysis of file: ${filePath}`);\n    updateStatus(`$(sync~spin) Analyzing ${filePath}...`);\n\n    await analyzePaths([filePath], onAnalysisComplete);\n  } catch (error) {\n    Logger.error(`Error analyzing file ${filePath}`, error as Error);\n    vscode.window.showErrorMessage(\n      `Error analyzing file: ${(error as Error).message}`\n    );\n    updateStatus(\"$(search) Find Dead Code\");\n  }\n}\n\n/**\n * Analyze a list of paths for dead code\n */\nasync function analyzePaths(\n  paths: string[],\n  onAnalysisComplete: (items: DeadCodeItem[]) => void\n): Promise<void> {\n  if (paths.length === 0) {\n    vscode.window.showInformationMessage(\"No paths to analyze\");\n    updateStatus(\"$(search) Find Dead Code\");\n    return;\n  }\n\n  try {\n    const analyzer = new PythonAnalyzer();\n    const result = await analyzer.analyze(paths);\n\n    if (!result.success) {\n      if (result.errors.length > 0) {\n        vscode.window.showErrorMessage(\n          `Analysis failed: ${result.errors.join(\", \")}`\n        );\n      } else {\n        vscode.window.showErrorMessage(\"Analysis failed\");\n      }\n      updateStatus(\"$(search) Find Dead Code\");\n      return;\n    }\n\n    if (result.deadCodeItems.length === 0) {\n      vscode.window.showInformationMessage(\"No dead code found\");\n      updateStatus(\"$(check) No dead code found\");\n      setTimeout(() => {\n        updateStatus(\"$(search) Find Dead Code\");\n      }, 3000);\n      onAnalysisComplete([]);\n      return;\n    }\n\n    updateStatus(\n      `$(alert) Found ${result.deadCodeItems.length} dead code items`\n    );\n    onAnalysisComplete(result.deadCodeItems);\n  } catch (error) {\n    Logger.error(\"Error analyzing paths\", error as Error);\n    vscode.window.showErrorMessage(\n      `Error during analysis: ${(error as Error).message}`\n    );\n    updateStatus(\"$(search) Find Dead Code\");\n  }\n}\n\n/**\n * Update the status bar item text\n */\nfunction updateStatus(text: string): void {\n  statusBarItem.text = text;\n}\n","import * as vscode from \"vscode\";\nimport * as path from \"path\";\nimport { IAnalyzer, DeadCodeItem, AnalysisResult } from \"../analyzer\";\nimport {\n  isVultureInstalled,\n  installVulture,\n  runVultureAnalysis,\n} from \"./vulture\";\nimport { Logger } from \"../../utils/logging\";\n\n/**\n * Python analyzer implementation using Vulture for dead code detection\n */\nexport class PythonAnalyzer implements IAnalyzer {\n  /**\n   * Get the language ID supported by this analyzer\n   */\n  public getLanguageId(): string {\n    return \"python\";\n  }\n\n  /**\n   * Check if the analyzer dependencies are available\n   */\n  public async isAvailable(): Promise<boolean> {\n    const installed = await isVultureInstalled();\n    if (!installed) {\n      const message = \"Vulture is not installed. Would you like to install it?\";\n      const install = \"Install\";\n      const manualInstall = \"Manual Install\";\n      const showInstructions = \"Show Instructions\";\n      const cancel = \"Cancel\";\n\n      const response = await vscode.window.showWarningMessage(\n        message,\n        install,\n        manualInstall,\n        showInstructions,\n        cancel\n      );\n\n      if (response === install) {\n        const success = await this.installDependencies();\n        if (!success) {\n          vscode.window.showErrorMessage(\n            \"Automatic installation failed. Please try installing manually.\"\n          );\n        }\n\n        // Recheck if Vulture is now installed\n        return await isVultureInstalled();\n      } else if (response === manualInstall) {\n        // Open a terminal for manual installation\n        const terminal = vscode.window.createTerminal(\"Vulture Installation\");\n        terminal.show();\n        terminal.sendText(\"pip install vulture --user\");\n\n        vscode.window.showInformationMessage(\n          \"After installation completes, please try analyzing again.\"\n        );\n\n        return false;\n      } else if (response === showInstructions) {\n        // Show a more detailed information message with instructions\n        vscode.window.showInformationMessage(\n          \"To install Vulture manually:\\n\\n\" +\n            \"1. Open a terminal\\n\" +\n            \"2. Run: pip install vulture --user\\n\" +\n            \"3. Restart VS Code\\n\\n\" +\n            \"If that doesn't work, try with pip3 instead of pip.\"\n        );\n        return false;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Install dependencies required by the analyzer\n   */\n  public async installDependencies(): Promise<boolean> {\n    return installVulture();\n  }\n\n  /**\n   * Analyze the given paths for dead code\n   */\n  public async analyze(paths: string[]): Promise<AnalysisResult> {\n    // Ensure vulture is installed\n    if (!(await this.isAvailable())) {\n      return {\n        deadCodeItems: [],\n        errors: [\n          \"Vulture is not installed. Please install it to use the Python analyzer.\",\n        ],\n        warnings: [],\n        success: false,\n      };\n    }\n\n    // Get configuration\n    const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n    const minConfidence = config.get<number>(\"minConfidence\", 60);\n\n    // Run analysis\n    return runVultureAnalysis(paths, minConfidence);\n  }\n\n  /**\n   * Get the URI for navigating to a dead code item\n   */\n  public getDeadCodeUri(item: DeadCodeItem): vscode.Uri {\n    return vscode.Uri.file(item.filePath);\n  }\n\n  /**\n   * Get the range for highlighting a dead code item\n   */\n  public getDeadCodeRange(item: DeadCodeItem): vscode.Range {\n    // Vulture only provides the line number, so we use the full line\n    const line = item.lineNumber - 1; // Convert to 0-based\n    return new vscode.Range(line, 0, line, 0);\n  }\n\n  /**\n   * Dispose of any resources\n   */\n  public dispose(): void {\n    // No resources to dispose\n  }\n\n  /**\n   * Get workspace Python files\n   */\n  public static async getWorkspacePythonFiles(): Promise<string[]> {\n    const pythonFiles: string[] = [];\n\n    // Get all workspace folders\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n    if (!workspaceFolders) {\n      return pythonFiles;\n    }\n\n    // Get configuration for exclude patterns\n    const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n    const excludePatterns = config.get<string[]>(\"excludePatterns\", [\n      \"**/venv/**\",\n      \"**/node_modules/**\",\n      \"**/.*/**\",\n    ]);\n\n    // Join exclude patterns for the findFiles exclude parameter\n    const excludePattern =\n      excludePatterns.length > 0 ? `{${excludePatterns.join(\",\")}}` : null;\n    Logger.debug(`Using exclude pattern: ${excludePattern}`);\n\n    // Find Python files\n    for (const folder of workspaceFolders) {\n      try {\n        const pattern = new vscode.RelativePattern(folder, \"**/*.py\");\n        const files = await vscode.workspace.findFiles(pattern, excludePattern);\n\n        // Convert to path strings\n        for (const file of files) {\n          pythonFiles.push(file.fsPath);\n        }\n      } catch (error) {\n        Logger.error(\n          `Error finding Python files in ${folder.name}`,\n          error as Error\n        );\n      }\n    }\n\n    return pythonFiles;\n  }\n\n  /**\n   * Get Python files in the given folder\n   */\n  public static async getPythonFilesInFolder(\n    folderPath: string\n  ): Promise<string[]> {\n    try {\n      const folder = vscode.workspace.getWorkspaceFolder(\n        vscode.Uri.file(folderPath)\n      );\n      if (!folder) {\n        return [];\n      }\n\n      // Get configuration for exclude patterns\n      const config = vscode.workspace.getConfiguration(\"deadCodeFinder\");\n      const excludePatterns = config.get<string[]>(\"excludePatterns\", [\n        \"**/venv/**\",\n        \"**/node_modules/**\",\n        \"**/.*/**\",\n      ]);\n\n      // Join exclude patterns for the findFiles exclude parameter\n      const excludePattern =\n        excludePatterns.length > 0 ? `{${excludePatterns.join(\",\")}}` : null;\n\n      const pattern = new vscode.RelativePattern(\n        folder,\n        path.join(path.relative(folder.uri.fsPath, folderPath), \"**/*.py\")\n      );\n      const files = await vscode.workspace.findFiles(pattern, excludePattern);\n\n      return files.map((file) => file.fsPath);\n    } catch (error) {\n      Logger.error(\n        `Error finding Python files in ${folderPath}`,\n        error as Error\n      );\n      return [];\n    }\n  }\n}\n","module.exports = require(\"fs\");","module.exports = require(\"path\");","import * as vscode from \"vscode\";\nimport { DeadCodeItem } from \"../analyzers/analyzer\";\nimport { Logger } from \"../utils/logging\";\n\n/**\n * Diagnostics collection for dead code warnings\n */\nlet diagnosticsCollection: vscode.DiagnosticCollection;\n\n/**\n * Initialize the diagnostics provider\n */\nexport function initDiagnosticsProvider(\n  context: vscode.ExtensionContext\n): void {\n  // Create diagnostics collection\n  diagnosticsCollection =\n    vscode.languages.createDiagnosticCollection(\"deadCodeFinder\");\n  context.subscriptions.push(diagnosticsCollection);\n\n  Logger.debug(\"Diagnostics provider initialized\");\n}\n\n/**\n * Update diagnostics for dead code items\n */\nexport function updateDiagnostics(items: DeadCodeItem[]): void {\n  // Clear existing diagnostics\n  diagnosticsCollection.clear();\n\n  // Group by file\n  const fileMap = new Map<string, DeadCodeItem[]>();\n\n  for (const item of items) {\n    if (!fileMap.has(item.filePath)) {\n      fileMap.set(item.filePath, []);\n    }\n    fileMap.get(item.filePath)!.push(item);\n  }\n\n  // Create diagnostics for each file\n  fileMap.forEach((fileItems, filePath) => {\n    const diagnostics: vscode.Diagnostic[] = [];\n\n    for (const item of fileItems) {\n      const lineNumber = Math.max(0, item.lineNumber - 1); // Convert to 0-based\n      const range = new vscode.Range(\n        lineNumber,\n        0,\n        lineNumber,\n        Number.MAX_SAFE_INTEGER\n      );\n\n      // Create diagnostic with appropriate severity based on confidence\n      const diagnostic = new vscode.Diagnostic(\n        range,\n        `Unused ${item.type}: '${item.name}' (${item.confidence}% confidence)`,\n        getDiagnosticSeverity(item.confidence)\n      );\n\n      // Add code and source\n      diagnostic.code = \"dead-code\";\n      diagnostic.source = \"Dead Code Finder\";\n\n      // Add related information if available\n      if (item.details) {\n        diagnostic.relatedInformation = [\n          new vscode.DiagnosticRelatedInformation(\n            new vscode.Location(vscode.Uri.file(item.filePath), range),\n            item.details\n          ),\n        ];\n      }\n\n      diagnostics.push(diagnostic);\n    }\n\n    // Add diagnostics to collection\n    diagnosticsCollection.set(vscode.Uri.file(filePath), diagnostics);\n  });\n\n  Logger.debug(\n    `Updated diagnostics for ${items.length} items across ${fileMap.size} files`\n  );\n}\n\n/**\n * Clear all diagnostics\n */\nexport function clearDiagnostics(): void {\n  diagnosticsCollection.clear();\n  Logger.debug(\"Cleared all diagnostics\");\n}\n\n/**\n * Get diagnostic severity based on confidence level\n */\nfunction getDiagnosticSeverity(confidence: number): vscode.DiagnosticSeverity {\n  if (confidence >= 90) {\n    return vscode.DiagnosticSeverity.Warning;\n  } else if (confidence >= 70) {\n    return vscode.DiagnosticSeverity.Information;\n  } else {\n    return vscode.DiagnosticSeverity.Hint;\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["context","treeDataProvider","DeadCodeTreeProvider","treeView","vscode","window","createTreeView","showCollapseAll","subscriptions","push","DeadCodeTreeItemType","DeadCodeTreeItem","TreeItem","label","type","deadCodeItem","children","constructor","super","FILE","TreeItemCollapsibleState","Expanded","None","this","iconPath","light","path","join","__filename","dark","description","confidence","tooltip","details","name","lineNumber","command","title","arguments","contextValue","DEAD_CODE_ITEM","_onDidChangeTreeData","EventEmitter","onDidChangeTreeData","event","_items","_treeItems","refresh","items","Logger","debug","length","buildTreeItems","fire","undefined","getTreeItem","element","getChildren","Promise","resolve","getItems","fileMap","Map","item","filePath","has","set","get","result","forEach","fileItems","sort","a","b","fileItem","basename","dirname","localeCompare","openDeadCodeCommand","commands","registerCommand","async","info","uri","Uri","file","document","workspace","openTextDocument","editor","showTextDocument","Math","max","range","lineAt","revealRange","TextEditorRevealType","InCenter","selection","Selection","start","end","error","showErrorMessage","message","openDeadCode","openSettingsCommand","executeCommand","openSettings","getDeadCodeItems","generateWhitelistCommand","showInformationMessage","generateWhitelist","generateWhitelistFromResults","whitelistItemCommand","whitelistSingleItem","initialize","initDiagnosticsProvider","deadCodeItems","registerDeadCodeTreeView","registerAnalyzeCommand","getConfiguration","updateDiagnostics","clearDiagnostics","registerNavigationCommands","registerWhitelistCommands","configWatcher","onDidChangeConfiguration","e","affectsConfiguration","config","logLevel","fileWatcher","onDidSaveTextDocument","languageId","fileName","setupAutoAnalysis","withProgress","location","ProgressLocation","Notification","cancellable","progress","report","increment","executePythonCommand","code","verifyResult","isVultureInstalled","stderr","then","terminal","createTerminal","show","sendText","paths","minConfidence","errors","warnings","success","args","toString","whitelistFile","fs","existsSync","processResult","parseVultureOutput","err","VULTURE_OUTPUT_PATTERN","stdout","lines","split","line","trim","match","_","parseInt","module","exports","require","targetPath","whitelistPath","workspaceFolders","defaultUri","fsPath","DEFAULT_WHITELIST_FILENAME","showSaveDialog","filters","generateWhitelistFile","generateWhitelistEntry","fileExt","extname","substring","replace","content","uniqueItems","values","writeFileSync","LogLevel","static","INFO","_outputChannel","createOutputChannel","configLevel","_logLevel","getLogLevelFromString","setLogLevel","level","log","DEBUG","warn","WARN","fullMessage","stack","ERROR","formattedMessage","Date","toISOString","appendLine","toLowerCase","testCommand","process","platform","testArgs","options","pythonConfig","pythonPaths","env","VIRTUAL_ENV","unshift","startsWith","includes","update","ConfigurationTarget","Global","HOME","versionManagerPaths","cp","spawn","on","data","onAnalysisComplete","statusBarItem","createStatusBarItem","StatusBarAlignment","Left","text","analyzeCommand","analyzeWorkspace","analyzeFileCommand","activeTextEditor","analyzeFile","showWarningMessage","updateStatus","pythonFiles","PythonAnalyzer","getWorkspacePythonFiles","analyzePaths","analyzer","analyze","setTimeout","getLanguageId","isAvailable","install","manualInstall","showInstructions","cancel","response","installDependencies","installVulture","runVultureAnalysis","getDeadCodeUri","getDeadCodeRange","Range","dispose","excludePatterns","excludePattern","folder","pattern","RelativePattern","files","findFiles","getPythonFilesInFolder","folderPath","getWorkspaceFolder","relative","map","diagnosticsCollection","languages","createDiagnosticCollection","clear","diagnostics","Number","MAX_SAFE_INTEGER","diagnostic","Diagnostic","DiagnosticSeverity","Warning","Information","Hint","source","relatedInformation","DiagnosticRelatedInformation","Location","size","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}